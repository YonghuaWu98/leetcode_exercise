# 图的应用
## 1.最小生成树
> 最小生成树：一个连通图的生成树包含图的所有顶点，并且只含尽可能少的边。
> 对于生成树来说，若砍去一条边，则会使生成树变成非连通图；若给它增加一条边，则会形成图中的一条回路。

### 解决算法：
>1. Prim算法：与节点数相关，时间复杂度为O(v^2), 适合求解边稠密的图的最小生成树。
>2. Kruskal算法: 与边数相关，时间复杂度为O(ElogE),采用堆来存放边可以优化到logE,适合边稀疏顶点较多的图

>结论：稀疏图用kruskal，稠密图用prim


### Prim三部曲
>1. 选距离生成树最近节点
>2. 最近节点（cur）加入到生成树
>3. 更新非生成树节点到生成树的距离（即更新dist数组）


### Kruskal
>对边的权值进行排序，并用并查集记录当前边对应的两个节点是否属于同一个集合，属于舍弃当前边，不属于则相加

## 2.最短路径

## 广度优先搜索（适用于无权图或者权重都相等的图）

## Dijkstra
>求解非负权有向图上单源最短路径的算法，某一顶点到其他顶点的最短路径。



#### 求解三部曲
>1. 选择源点到那个节点最近且该节点未被访问过
>2. 该最近节点被标记访问
>3. 更新非访问节点到源点的距离

#### 1.朴素 Dijkstra 求解过程(适用于稠密图)
**定义1:** `g[i][j]` 表示节点 i 到节点 j 这条边的边权。如果没有 i 到 j 的边，则 `g[i][j]=∞`。

**定义2:** `dis[i]` 表示起点 k 到节点 i 的最短路长度，一开始 `dis[k]=0`，其余 `dis[i]=∞` 表示尚未计算出。

- 首先更新起点 `k` 到其邻居 `y` 的最短路，即更新 `dis[y]` 为 `g[k][y]`。
- 然后取除了起点 `k` 以外的 `dis[i]` 的最小值，假设最小值对应的节点是 3。此时可以断言：`dis[3]` 已经是 `k` 到 3 的最短路长度，
  不可能有其它 `k` 到 3 的路径更短！反证法：假设存在更短的路径，那我们一定会从 `k` 出发经过一个点 `u`，它的 `dis[u]` 比 `dis[3]` 还要小，
  然后再经过一些边到达 3，得到更小的 `dis[3]`。但 `dis[3]` 已经是最小的了，并且图中没有负数边权，所以 u 是不存在的，矛盾。
  故原命题成立，此时我们得到了 `dis[3]` 的最终值。
- 用节点 3 到其邻居 `y` 的边权 `g[3][y]` 更新 `dis[y]`：如果 `dis[3]+g[3][y]<dis[y]`，那么更新 `dis[y]` 为 `dis[3]+g[3][y]`，否则不更新。
- 然后取除了节点 `k`,3 以外的 `dis[i]` 的最小值，重复上述过程。
- 由数学归纳法可知，这一做法可以得到每个点的最短路。当所有点的最短路都已确定时，算法结束。
#### 复杂度分析
- 时间复杂度：`O(n^2)`
- 空间复杂度：`O(n^2)`
#### 2.堆优化 Dijkstra （适用于稀疏图）
寻找最小值的过程可以用一个最小堆来快速完成：
- 一开始把(`dis[k],[k])`)二元组入堆。
- 当节点 x 首次出堆时, `dis[x]` 就是写法一中寻找的最小最短路。
- 更新 `dis[y]` 时, 把(`dis[y], y`) 二元组入堆。
#### 复杂度分析
- 时间复杂度：O(E * (N + logE)) E为边的数量，N为节点数量
- 空间复杂度：O(log(N^2))

### Floyd
> 用来求任意两个结点之间的最短路，适用于任何图，无论有向无向，边权正负，但是最短路径必须存在。（不能有个负环）

**算法思想**
>Floyd算法的基本思想是:递推产生一个n阶方阵序列 `A^(-1) A^(0)...... A^(n-1)`,其中 `A[k][i][j]`表示从顶点i到顶点j的路径长度，k表示绕行第k个顶点的运算步骤。
> 初始时，对于任意两个顶点i和j，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度:若它们之间不存在有向边，则以∞作为它们之间的最短路径长度。
> 以后逐步尝试在原路径中加入顶点 k(k=0,1,…,n-1)作为中间顶点。若增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径。
>
**算法描述:**
> A(-1)[i][j] = arcs[i][j]
> 
> A(k)[i][j] = Min { A(k - 1)[i][j], A(k - 1)[i][k] + A(k - 1)][k][j] }, k =0, 1,……,n-1

