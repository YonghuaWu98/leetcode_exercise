# 图论
    
## 基本概念
    图的定义：图G由顶点集V和边集E组成，记为G = (V, E), 其中V(G)表示图G中顶点的有限非空集；  
    E（G）表示图G中顶点之间的关系集合。若V = {v1, v2, v3, ...,vn},则用|V| 表示图G中顶点  
    的个数， E = {(u，v)} ,用|E|表示图G中边的条数。  
    
#### 完全图： 
    对于无向图，|E|的取值范围 0 - n(n - 1)/2, 有n(n - 1)/2条边的无向图称为完全图，在完全图中任意两个顶点
    之间都存在边。
            
    对于有向图，|E|的取值范围 0 - n(n - 1), 有n(n - 1)条弧的有向图称为有向完全图，在有向完全图中任意两个
    顶点之间都存在方向相反的两条弧。          
            
              
#### 子图： 
    设有两个图 G = (V, E) 和 G'= (V', E'), 若V'是V的子集， 且E'是E的子集，则称G'是G的子图。
    若满足 V' = V的子图 G'，则称G'为 G的生成子图。

#### 连通、连通图和连通分量  
    在无向图中两个顶点之间存在一条路径，则称这两个顶点之间是连通的。  
    
    如果图中的任意两个顶点都是连通的，称其为连通图。  
    
    无向图中极大连通子图称为连通分量。
#### 强连通图、强连通分量
    在有向图中，如果一对顶点v和w，从v到w和从w到v之间都有路径，则称这两个顶点是强连通的。  
    
    若图中任意两个顶点都是强连通的，那么称此图为强连通图。  
    
    有向图中的极大强连通子图称为有向图的强连通分量。
#### 生成树、生成森林
    连通图的生成树是包含图中全部顶点的一个极小连通子图。若图中顶点数为n，则它的生成树含有n - 1条边。
    对于生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则会形成一个回路。在非连通图中，
    连通分量的生成树构成了非连通图的生成森林。
    
    注意：极大连通子图是无向图的连通分量，极大即要求该连通子图包含其所有的边；极小连通子图是既要保持图连通又要使得边数最少的子图。
    
#### 顶点的度、入度和出度
    无向图的所有顶点的度数之和等于边数的两倍  
    有向图所有顶点的入度之和和出度之和相等
    
## 图的存储（代码见GraphStorage）
#### 1. 直接存边：
    使用一个数组来存边，数组中的每一个元素都包含一条边的起点和终点（带边权的图还包含边权），或者使用多个数组分别存起点，终点和边权

#### 复杂度分析
         
       1. 查询是否存在某条边：O(m)。
       
       2. 遍历一个点的所有出边：O(m)。
    
       3. 遍历整张图：O(nm)。
    
       4. 空间复杂度：O(m)。  
   
####  应用
  
      由于直接存边的遍历效率低下，一般不用于遍历图。
      
      在 Kruskal 算法中，由于需要将边按边权排序，需要直接存边。
      
      在有的题目中，需要多次建图（如建一遍原图，建一遍反图），此时既可以使用多个其它数据结构来同时存储多张图，也可以将边直接存下来，
      需要重新建图时利用直接存下的边来建图。
#### 2. 邻接矩阵：

    使用一个二维数组 adj 来存边，其中 adj[u][v] 为 1 表示存在 u 到 v 的边，为 0 表示不存在。如果是带边权的图，可以在 adj[u][v] 中存储 u 到 v 的边的边权。  
    
####复杂度

       1. 查询是否存在某条边：O(1)。
       
       2. 遍历一个点的所有出边：O(n)。
       
       3. 遍历整张图：O(n^2)。
       
       4. 空间复杂度：O(n^2)。
   
####应用

       邻接矩阵只适用于没有重边（或重边可以忽略）的情况。
       
       其最显著的优点是可以 O(1) 查询一条边是否存在。
       
       由于邻接矩阵在稀疏图上效率很低（尤其是在点数较多的图上，空间无法承受），所以一般只会在稠密图上使用邻接矩阵。
       
#### 3. 邻接表:

    使用一个支持动态增加元素的数据结构构成的数组，如 List[] odj 来存边，其中 odj.get(u) 存储的是点 u 的所有出边的相关信息（终点、边权等）。  
    
####复杂度  

    说明：d^+(u) 为 u 的出度，也就是odj.get(u).size()  
    
    1. 查询是否存在 u 到 v 的边：O(d^+(u))（如果事先进行了排序就可以使用 二分查找 做到 O(\log(d^+(u)))）。
    
    2. 遍历点 u 的所有出边：O(d^+(u))。
    
    3. 遍历整张图：O(n+m)。
    
    4. 空间复杂度：O(m)。  
    
#### 应用  

    存各种图都很适合，除非有特殊需求（如需要快速查询一条边是否存在，且点数较少，可以使用邻接矩阵）。
    
    尤其适用于需要对一个点的所有出边进行排序的场合。  
    
#### 4. 链式前向星:  

    实质是链表实现的邻接表法   
         
#### 复杂度  

    1. 查询是否存在 u 到 v 的边：O(d^+(u))。
    
    2. 遍历点 u 的所有出边：O(d^+(u))。
    
    3. 遍历整张图：O(n+m)。
    
    4. 空间复杂度：O(m)。

#### 应用  

    存各种图都很适合，但不能快速查询一条边是否存在，也不能方便地对一个点的出边进行排序。
    
    优点是边是带编号的，有时会非常有用，而且如果 cnt 的初始值为奇数，存双向边时 i ^ 1 即是 i 的反边（常用于网络流）。 
     
    
## 图的应用
#### 深度优先搜索（DFS)
1. 应用场景：查询（强）连通分量的个数
2. 代码模板： 
```java
    //建图
    //采用邻接表建图, n为图中结点个数
    List<Integer>[] g = new ArrayList[n];
    //初始化
    Arrays.setAll(g, new ArrayList<>());
    for (int[] e : 边数组) {
        int x = e[0];
        int y = e[1];
        //无向边
        g[x].add(y);
        g[y].add(x);
        //有向边
        g[x].add(y);
    }
    // visited数组用于记录访问过的结点
    boolean[] visited = new boolean[n];
    int ans = 0;
    for (int i = 0; i < n; i++) {
        if (!visited[i]) {
            dfs(i, g, visited);
            ans += 1; //统计连通分量的个数
        }       
    }   
    //dfs函数主体部分
    public void dfs(int cur, List<Integer> g, boolean[] visited) {
        
        for (int e : g[i]) {
            if (!visited[e]) {
                visited[i] = true; //表示结点已经访问过
                dfs(e, g, visited);
            }
            
        }
    }
    
```
#### 广度优先搜索(BFS)
1. 应用场景: 最短路径（权重统一，例如都为1）
2. 代码模板：
```java
    //通常用于求两结点之间的最短路径，不同题型有相应的变化
    //建图过程与DFS相似
    List<Integer>[] g = new ArrayList[n];
    //初始化
    Arrays.setAll(g, e -> new ArrayList<>());
    for (int[] e : 边数组) {
        int x = e[0];
        int y = e[1];
        //无向边
        g[x].add(y);
        g[y].add(x);
        //有向边
        g[x].add(y);
    }
    // visited数组用于记录访问过的结点
    boolean[] visited = new boolean[n];
    // 利用队列的先进先出进行广度搜索
    Deque<Integer> q = new DequeArray<>();
    q.offer(0);//让起始结点入队
    visited[0] = true;
    int ans = 0;//当前距离
    while(!q.isEmpty()) {
        for (int i = 0; i < q.size(); i++) {
            int cur = q.poll();
            //当前结点访问过
            visited[cur] = true;
            for (int x : g[cur]) {
                if (!visited[x]) {
                    q.offer(x);
                }   
            }        
        }
        ans++;
    }
```
#### 最小生成树


####  最短路径